import { useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/features/auth";
import { supabase } from "@/integrations/supabase/client";
import DOMPurify from "dompurify";

interface DiagnosisReport {
  clarityScore: number;
  hookAnalysis: string;
  ctaAnalysis: string;
  mentalTriggers: string[];
  suggestions: string[];
}

export const useDiagnosis = () => {
  const [adText, setAdText] = useState<string>("");
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [diagnosisReport, setDiagnosisReport] = useState<DiagnosisReport | null>(null);
  const [optimizedAds, setOptimizedAds] = useState<string[]>([]);
  const [isOptimizing, setIsOptimizing] = useState(false);
  const { toast } = useToast();
  const { user } = useAuth();

  // Fun√ß√£o para validar e formatar o texto do an√∫ncio
  const validateAndFormatText = (text: string): { isValid: boolean; formattedText?: string; error?: string } => {
    if (!text.trim()) {
      return { isValid: false, error: "O texto do an√∫ncio n√£o pode estar vazio." };
    }
    
    // Extrair apenas o texto sem as tags HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    const textOnly = tempDiv.textContent || tempDiv.innerText || '';
    
    if (textOnly.length < 50) {
      return { isValid: false, error: "O texto do an√∫ncio deve ter no m√≠nimo 50 caracteres." };
    }
    
    if (textOnly.length > 1000) {
      return { isValid: false, error: "O texto do an√∫ncio deve ter no m√°ximo 1000 caracteres." };
    }
    
    // Sanitizar o HTML para remover scripts maliciosos
    const sanitizedHtml = DOMPurify.sanitize(text);
    
    // Para o caso de precisarmos apenas do texto simples para a API
    const plainText = textOnly.trim().replace(/\s+/g, ' ');
      
    return { isValid: true, formattedText: plainText, originalHtml: sanitizedHtml };
  };

  const saveToHistory = async (originalHtml: string, diagnosisReport: DiagnosisReport, optimizedAds: string[] = []) => {
    if (!user) return;

    try {
      // Extrair texto puro para o t√≠tulo
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = originalHtml;
      const textOnly = tempDiv.textContent || tempDiv.innerText || '';
      
      // Criar conte√∫do combinando HTML e relat√≥rio
      const content = `TEXTO ORIGINAL:\n${originalHtml}\n\n---\n\nRELAT√ìRIO DE DIAGN√ìSTICO:\n${JSON.stringify(diagnosisReport, null, 2)}\n\n---\n\nVERS√ïES OTIMIZADAS:\n${optimizedAds.join('\n\n')}`;
      
      const inputData = JSON.parse(JSON.stringify({
        originalHtml,
        diagnosisReport,
        optimizedAds
      }));
      
      const { error } = await supabase
        .from('history_items')
        .insert({
          user_id: user.id,
          type: 'diagnosis',
          title: `Diagn√≥stico: ${textOnly.substring(0, 50)}...`,
          content: content,
          input_data: inputData
        });

      if (error) {
        console.error('Error saving to history:', error);
        toast({
          title: "Erro ao salvar",
          description: "N√£o foi poss√≠vel salvar no hist√≥rico.",
          variant: "destructive",
        });
      } else {
        toast({
          title: "Salvo no hist√≥rico!",
          description: "O diagn√≥stico foi salvo no seu hist√≥rico.",
        });
      }
    } catch (error) {
      console.error('Error saving to history:', error);
      toast({
        title: "Erro ao salvar",
        description: "N√£o foi poss√≠vel salvar no hist√≥rico.",
        variant: "destructive",
      });
    }
  };

  const handleAnalyze = async () => {
    // Validar e formatar o texto do an√∫ncio
    const validation = validateAndFormatText(adText);
    if (!validation.isValid) {
      toast({
        title: "Erro de valida√ß√£o",
        description: validation.error,
        variant: "destructive",
      });
      return;
    }

    // Usar o texto formatado para a API e o HTML original para salvar
    const formattedAdText = validation.formattedText!;
    const originalHtml = validation.originalHtml;
    
    setIsAnalyzing(true);

    try {
      console.log("Analisando an√∫ncio:", formattedAdText);
      
      // Verificar se o usu√°rio pode usar o servi√ßo (verificar limite do plano)
      try {
        // Chamada para fun√ß√£o que verifica uso do recurso (exemplo)
        const { data, error } = await supabase.rpc('check_feature_usage', {
          user_uuid: user?.id,
          feature: 'diagnostics'
        });
        
        if (error) throw error;
        
        // Se n√£o puder usar o recurso, mostrar mensagem de erro
        if (data && data[0] && !data[0].can_use) {
          throw new Error('Voc√™ atingiu o limite de diagn√≥sticos do seu plano.');
        }
        
      } catch (usageError) {
        // Se ocorrer erro na verifica√ß√£o de uso, apenas logar e continuar
        console.error('Erro ao verificar uso da funcionalidade:', usageError);
      }
      
      // Simular chamada √† API de diagn√≥stico
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Mock do relat√≥rio de diagn√≥stico
      const mockReport: DiagnosisReport = {
        clarityScore: 7.5,
        hookAnalysis: "O gancho inicial est√° adequado, mas poderia ser mais impactante. Considere usar uma pergunta provocativa ou uma estat√≠stica surpreendente.",
        ctaAnalysis: "A chamada para a√ß√£o est√° presente, mas n√£o transmite urg√™ncia. Adicione elementos de escassez ou tempo limitado.",
        mentalTriggers: ["Urg√™ncia", "Autoridade", "Prova Social"],
        suggestions: [
          "Adicione uma pergunta provocativa no in√≠cio",
          "Inclua n√∫meros ou estat√≠sticas para credibilidade",
          "Reforce a chamada para a√ß√£o com urg√™ncia",
          "Use mais gatilhos de prova social"
        ]
      };
      
      // Incrementar contador de uso da funcionalidade
      if (user) {
        try {
          await supabase.rpc('increment_usage_counter', {
            p_user_uuid: user.id,
            p_feature_type: 'diagnostics'
          });
        } catch (error) {
          console.error('Erro ao incrementar contador de uso:', error);
        }
      }
      
      setDiagnosisReport(mockReport);
      
      // Salvar diagn√≥stico no hist√≥rico
      await saveToHistory(originalHtml, mockReport);
      
      toast({
        title: "An√°lise conclu√≠da!",
        description: "Seu an√∫ncio foi analisado com sucesso.",
      });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : "Tente novamente em alguns instantes.";
      toast({
        title: "Erro na an√°lise",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsAnalyzing(false);
    }
  };

  const handleOptimize = async () => {
    if (!diagnosisReport) return;
    
    setIsOptimizing(true);

    try {
      console.log("Otimizando an√∫ncio com base no diagn√≥stico:", diagnosisReport);
      
      // Simular chamada √† API
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Mock de an√∫ncios otimizados
      const mockOptimizedAds = [
        "üö® Voc√™ sabia que 87% das pessoas falham no marketing digital? Descubra o m√©todo exato que transformou mais de 1.000 empreendedores em especialistas. ‚è∞ √öltimas 24h com desconto! Clique agora! üëá",
        "‚ùì Por que seus concorrentes vendem mais que voc√™? A resposta est√° no nosso curso comprovado por + de 500 alunos. üî• Apenas hoje: 50% OFF! Garantir minha vaga ‚Üí",
        "‚úÖ M√©todo aprovado por 1.000+ empreendedores est√° com vagas limitadas! Transforme seu neg√≥cio em 30 dias ou seu dinheiro de volta. ‚ö° Restam apenas 12 vagas! Quero me inscrever!"
      ];
      
      setOptimizedAds(mockOptimizedAds);
      
      // Atualizar hist√≥rico com as vers√µes otimizadas
      await saveToHistory(adText, diagnosisReport, mockOptimizedAds);
      
      toast({
        title: "Otimiza√ß√£o conclu√≠da!",
        description: "3 vers√µes otimizadas foram geradas.",
      });
    } catch (error) {
      toast({
        title: "Erro na otimiza√ß√£o",
        description: "Tente novamente em alguns instantes.",
        variant: "destructive",
      });
    } finally {
      setIsOptimizing(false);
    }
  };

  return {
    adText,
    setAdText,
    isAnalyzing,
    diagnosisReport,
    optimizedAds,
    isOptimizing,
    handleAnalyze,
    handleOptimize,
    validateAndFormatText
  };
};